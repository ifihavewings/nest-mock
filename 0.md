1. 要使用 CLI 创建控制器，只需执行 `nest g controller [name]` 命令即可。
2. passthrough 
```ts
@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.status(HttpStatus.OK);
  return [];
}
```
3. 要使用 CLI 创建服务，只需执行 `nest g service cats` 命令即可。

4. 控制反转

- 控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。

- 早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。

- Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式地用 new 建立 B 的对象。  采用依赖注入技术之后，A 的代码只需要定义一个 private 的B对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。IoC也可以理解为把流程的控制从应用程序转移到框架之中。以前，应用程序掌握整个处理流程；现在，控制权转移到了框架，框架利用一个引擎驱动整个流程的执行，框架会以相应的形式提供一系列的扩展点，应用程序则通过定义扩展的方式实现对流程某个环节的定制，“框架Call应用”。基于MVC的web应用程序就是如此。
  
- 实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。
```

5. DTO:在 NestJS 中，DTO（Data Transfer Object）是一种用于定义数据传输对象的方式。DTO 是一个简单的类，用于在不同的层之间传输数据，通常用于控制器（Controller）和服务（Service）之间的数据传递。DTO 可以帮助我们在不同的模块之间定义数据结构，提高代码的可读性和可维护性。
```
在 NestJS 中，DTO（Data Transfer Object）和接口（Interface）都用于定义数据结构，但它们有不同的使用场景和特点。

`DTO（Data Transfer Object）：`

DTO 通常用于在不同的层之间传输数据，例如控制器（Controller）和服务（Service）之间，或服务和数据库之间。
DTO 是一个类，它可以包含属性和方法，并且可以对数据进行验证和处理。
DTO 可以包含业务逻辑，例如数据验证、转换和清理。
DTO 可以被序列化成 JSON 格式，用于在网络上进行传输。

`接口（Interface）：`

接口通常用于描述对象的形状（Shape），它是一种用于约束对象结构的类型。
接口没有实际的实现，它只是一种类型的约定。
接口可以用于声明类、对象、函数的参数和返回值等的类型。
接口更适用于描述数据结构的形状，而不涉及业务逻辑。

`区别：`

`使用场景：`DTO 通常用于数据传输和业务逻辑处理，而接口通常用于描述数据结构的形状。

`功能：`DTO 可以包含业务逻辑和数据处理，而接口主要用于类型约束和结构描述。

`实现方式：`DTO 是一个具有属性和方法的类，而接口只是一个类型的描述，没有具体的实现。

在实际开发中，根据需要选择使用 DTO 还是接口。如果需要在不同的层之间传输数据，并且涉及到数据处理和验证，可以使用 DTO。如果只需要描述对象的结构，而不涉及业务逻辑，可以使用接口。

6. param, query, body, form-data

- /user/2 , 是param
- user?id=2, 是query
- { id: 2 }， 通过 post 请求的 body 传递， 是请求体
- form-data 用特殊的格式

7. 依赖注入，控制反转

一般来说既然都使用了装饰器去做一些AOP编程，后续为了彻底解耦还会使用依赖注入的模式。
先看代码:
ts复制代码class B { }
```typescript
class A {
  constructor(b: B) { 
    //类A依赖类B的实例
  }
}
​
// 将B的实例注入到a中
const a = new A(new B());
```
​

当一个类A依赖类B，但是只是去使用类B并不会对类B造成影响，也不控制类B的创建和销毁，这就是类B依赖注入 类A，这里类B的控制权不在类A里而在别的地方控制的方式也叫控制反转 （IOC）。
在上面的例子中，将类B依赖注入类A的代码是我们自己手动写的，也就是const a = new A(new B())，在实际项目里可能会有很多这样的类需要注入，全部我们自行手写比较混乱，所以需要一个IOC容器 统一管理这其中的依赖关系和行为。
这就是解释了DI/IOC/IOC容器的概念和之间的关系
